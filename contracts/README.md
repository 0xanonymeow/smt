# Sparse Merkle Tree Solidity Library

A gas-efficient Solidity implementation of Sparse Merkle Trees with complete state management.

## Installation

### Using Foundry

```bash
forge install 0xanonymeow/smt
```

Then in your contract:

```solidity
import {SparseMerkleTreeLib} from "smt/contracts/src/SparseMerkleTree.sol";
import {SparseMerkleTreeContract} from "smt/contracts/src/SparseMerkleTreeContract.sol";
```

## Features

- **Complete Tree Operations**: Insert, Update, Get with state management
- **Gas Optimized**: Assembly optimizations for critical paths
- **Proof Generation**: On-chain proof generation and verification
- **Event Emission**: Comprehensive events for off-chain indexing
- **Cross-Platform**: Compatible with Go implementation proofs
- **Access Control**: Built-in security and permission management

## Quick Start

### Using the Library

```solidity
pragma solidity ^0.8.19;

import {SparseMerkleTreeLib} from "smt/contracts/src/SparseMerkleTree.sol";

contract MyContract {
    using SparseMerkleTreeLib for SparseMerkleTreeLib.SMTStorage;
    
    SparseMerkleTreeLib.SMTStorage private smt;
    
    constructor() {
        smt.depth = 16; // Initialize with depth 16
    }
    
    function insertValue(uint256 index, bytes32 leaf, SparseMerkleTreeLib.Proof calldata oldProof) external {
        // Verify old proof (should be empty/default for new insertions)
        require(!oldProof.exists, "Key already exists");
        
        // Insert the new value
        SparseMerkleTreeLib.Proof memory newProof = smt.insert(index, leaf);
        
        // Emit event
        emit ValueInserted(index, leaf, smt.root);
    }
    
    function getValue(uint256 index) external view returns (SparseMerkleTreeLib.Proof memory) {
        return smt.get(index);
    }
    
    function getRoot() external view returns (bytes32) {
        return smt.root;
    }
}
```

### Using the Contract Template

```solidity
pragma solidity ^0.8.19;

import {SparseMerkleTreeContract} from "smt/contracts/src/SparseMerkleTreeContract.sol";

// Deploy this contract directly
SparseMerkleTreeContract tree = new SparseMerkleTreeContract(16);

// Insert a value
SparseMerkleTreeLib.Proof memory emptyProof;
tree.insert(1, keccak256("value"), emptyProof);

// Get the value
SparseMerkleTreeLib.Proof memory proof = tree.get(1);

// Get the root
bytes32 root = tree.root();
```

## API Reference

### Library Functions

```solidity
library SparseMerkleTreeLib {
    struct SMTStorage {
        mapping(bytes32 => bytes32[2]) db;
        mapping(bytes32 => bytes32) leaves;
        bytes32 root;
        uint16 depth;
    }
    
    struct Proof {
        bool exists;
        bytes32 leaf;
        bytes32 value;
        uint256 index;
        uint256 enables;
        bytes32[] siblings;
    }
    
    function insert(SMTStorage storage smt, uint256 index, bytes32 leaf) 
        external returns (Proof memory);
    
    function update(SMTStorage storage smt, uint256 index, bytes32 newLeaf) 
        external returns (Proof memory);
    
    function get(SMTStorage storage smt, uint256 index) 
        external view returns (Proof memory);
    
    function exists(SMTStorage storage smt, uint256 index) 
        external view returns (bool);
    
    function verifyProof(bytes32 leaf, uint256 index, uint256 enables, bytes32[] calldata siblings) 
        external pure returns (bool);
    
    function computeRoot(bytes32 leaf, uint256 index, uint256 enables, bytes32[] calldata siblings) 
        external pure returns (bytes32);
}
```

### Contract Interface

```solidity
interface ISparseMerkleTreeContract {
    event TreeUpdated(uint256 indexed index, bytes32 oldLeaf, bytes32 newLeaf, bytes32 newRoot);
    event TreeInserted(uint256 indexed index, bytes32 leaf, bytes32 newRoot);
    
    function insert(uint256 index, bytes32 leaf, SparseMerkleTreeLib.Proof calldata oldProof) external;
    function update(uint256 index, bytes32 newLeaf, SparseMerkleTreeLib.Proof calldata oldProof) external;
    function get(uint256 index) external view returns (SparseMerkleTreeLib.Proof memory);
    function root() external view returns (bytes32);
    function depth() external view returns (uint16);
}
```

## Gas Optimization

The library includes several gas optimizations:

- **Assembly Hash Function**: Optimized keccak256 implementation
- **Efficient Storage Layout**: Minimized storage operations
- **Proof Compression**: Efficient sibling encoding
- **Batch Operations**: Support for multiple operations in one transaction

## Testing

Run the test suite using Foundry:

```bash
cd contracts
forge test
forge test --gas-report
```

## Cross-Platform Compatibility

This library is designed to be compatible with the Go implementation. Proofs generated by the Go library can be verified on-chain and vice versa.

### Example: Verifying Go-generated Proof

```solidity
function verifyExternalProof(
    bytes32 leaf,
    uint256 index,
    uint256 enables,
    bytes32[] calldata siblings
) external pure returns (bool) {
    return SparseMerkleTreeLib.verifyProof(leaf, index, enables, siblings);
}
```

## Security Considerations

- Always verify old proofs before performing updates
- Implement proper access control for state-changing functions
- Be aware of gas limits for deep trees
- Validate all inputs, especially array lengths

## License

See the main project LICENSE file.